=== tests/cases/conformance/classes/members/privateNames/privateNameInInExpression.ts ===
// TODO(aclaymore) split up into separate cases

class Foo {
>Foo : Symbol(Foo, Decl(privateNameInInExpression.ts, 0, 0))

    #p1 = 1;
>#p1 : Symbol(Foo.#p1, Decl(privateNameInInExpression.ts, 2, 11))

    basics(v: any) {
>basics : Symbol(Foo.basics, Decl(privateNameInInExpression.ts, 3, 12))
>v : Symbol(v, Decl(privateNameInInExpression.ts, 4, 11))

        const a = #p1 in v; // Good - a is boolean
>a : Symbol(a, Decl(privateNameInInExpression.ts, 5, 13))
>v : Symbol(v, Decl(privateNameInInExpression.ts, 4, 11))

        const b = #p1 in v.p1.p2; // Good - b is boolean
>b : Symbol(b, Decl(privateNameInInExpression.ts, 7, 13))
>v : Symbol(v, Decl(privateNameInInExpression.ts, 4, 11))

        const c = #p1 in (v as {}); // Good - c is boolean
>c : Symbol(c, Decl(privateNameInInExpression.ts, 9, 13))
>v : Symbol(v, Decl(privateNameInInExpression.ts, 4, 11))

        const d = #p1 in (v as Foo); // Good d is boolean (not true)
>d : Symbol(d, Decl(privateNameInInExpression.ts, 11, 13))
>v : Symbol(v, Decl(privateNameInInExpression.ts, 4, 11))
>Foo : Symbol(Foo, Decl(privateNameInInExpression.ts, 0, 0))

        const e = #p1 in (v as unknown); // Bad - RHS of in must be object type or any
>e : Symbol(e, Decl(privateNameInInExpression.ts, 13, 13))
>v : Symbol(v, Decl(privateNameInInExpression.ts, 4, 11))

        const f = #p2 in v; // Bad - Invalid privateID
>f : Symbol(f, Decl(privateNameInInExpression.ts, 15, 13))
>v : Symbol(v, Decl(privateNameInInExpression.ts, 4, 11))

        const g = (#p1) in v; // Bad - private id is not an expression on it's own
>g : Symbol(g, Decl(privateNameInInExpression.ts, 17, 13))
>v : Symbol(v, Decl(privateNameInInExpression.ts, 4, 11))

        for (#p1 in v) { /* no-op */ } // Bad - 'in' not allowed
>v : Symbol(v, Decl(privateNameInInExpression.ts, 4, 11))

        for (let x in #p1 in v) { /* no-op */ } // Bad - rhs of in should be a object/any
>x : Symbol(x, Decl(privateNameInInExpression.ts, 21, 16))
>v : Symbol(v, Decl(privateNameInInExpression.ts, 4, 11))

        for (let x in #p1 in v as any) { /* no-op */ } // Good - weird but valid
>x : Symbol(x, Decl(privateNameInInExpression.ts, 23, 16))
>v : Symbol(v, Decl(privateNameInInExpression.ts, 4, 11))

    }
    precedence(v: any) {
>precedence : Symbol(Foo.precedence, Decl(privateNameInInExpression.ts, 25, 5))
>v : Symbol(v, Decl(privateNameInInExpression.ts, 26, 15))

        // '==' has lower precedence than 'in'
        // '<'  has same precedence than 'in'
        // '<<' has higher precedence than 'in'

        v == #p1 in v == v; // Good precedence: ((v == (#p1 in v)) == v)
>v : Symbol(v, Decl(privateNameInInExpression.ts, 26, 15))
>v : Symbol(v, Decl(privateNameInInExpression.ts, 26, 15))
>v : Symbol(v, Decl(privateNameInInExpression.ts, 26, 15))

        v << #p1 in v << v; // Good precedence: (v << (#p1 in (v << v)))
>v : Symbol(v, Decl(privateNameInInExpression.ts, 26, 15))
>v : Symbol(v, Decl(privateNameInInExpression.ts, 26, 15))
>v : Symbol(v, Decl(privateNameInInExpression.ts, 26, 15))

        v << #p1 in v == v; // Good precedence: ((v << (#p1 in v)) == v)
>v : Symbol(v, Decl(privateNameInInExpression.ts, 26, 15))
>v : Symbol(v, Decl(privateNameInInExpression.ts, 26, 15))
>v : Symbol(v, Decl(privateNameInInExpression.ts, 26, 15))

        v == #p1 in v < v; // Good precedence: (v == ((#p1 in v) < v))
>v : Symbol(v, Decl(privateNameInInExpression.ts, 26, 15))
>v : Symbol(v, Decl(privateNameInInExpression.ts, 26, 15))
>v : Symbol(v, Decl(privateNameInInExpression.ts, 26, 15))

        #p1 in v && #p1 in v; // Good precedence: ((#p1 in v) && (#p1 in v))
>v : Symbol(v, Decl(privateNameInInExpression.ts, 26, 15))
>v : Symbol(v, Decl(privateNameInInExpression.ts, 26, 15))
    }
    flow(u: unknown, fb: Foo | Bar, fs: FooSub, b: Bar, fsb: FooSub | Bar) {
>flow : Symbol(Foo.flow, Decl(privateNameInInExpression.ts, 40, 5))
>u : Symbol(u, Decl(privateNameInInExpression.ts, 41, 9))
>fb : Symbol(fb, Decl(privateNameInInExpression.ts, 41, 20))
>Foo : Symbol(Foo, Decl(privateNameInInExpression.ts, 0, 0))
>Bar : Symbol(Bar, Decl(privateNameInInExpression.ts, 94, 28))
>fs : Symbol(fs, Decl(privateNameInInExpression.ts, 41, 35))
>FooSub : Symbol(FooSub, Decl(privateNameInInExpression.ts, 92, 1))
>b : Symbol(b, Decl(privateNameInInExpression.ts, 41, 47))
>Bar : Symbol(Bar, Decl(privateNameInInExpression.ts, 94, 28))
>fsb : Symbol(fsb, Decl(privateNameInInExpression.ts, 41, 55))
>FooSub : Symbol(FooSub, Decl(privateNameInInExpression.ts, 92, 1))
>Bar : Symbol(Bar, Decl(privateNameInInExpression.ts, 94, 28))

        if (typeof u === 'object') {
>u : Symbol(u, Decl(privateNameInInExpression.ts, 41, 9))

            if (#p1 in u) {
>u : Symbol(u, Decl(privateNameInInExpression.ts, 41, 9))

                u; // good u is Foo
>u : Symbol(u, Decl(privateNameInInExpression.ts, 41, 9))

            } else {
                u; // good u is object | null
>u : Symbol(u, Decl(privateNameInInExpression.ts, 41, 9))
            }

            if (u !== null) {
>u : Symbol(u, Decl(privateNameInInExpression.ts, 41, 9))

                if (#p1 in u) {
>u : Symbol(u, Decl(privateNameInInExpression.ts, 41, 9))

                    u; // good u is Foo
>u : Symbol(u, Decl(privateNameInInExpression.ts, 41, 9))

                } else {
                    u; // good u is object
>u : Symbol(u, Decl(privateNameInInExpression.ts, 41, 9))
                }
            }
        }

        if (#p1 in fb) {
>fb : Symbol(fb, Decl(privateNameInInExpression.ts, 41, 20))

            fb; // good fb is Foo
>fb : Symbol(fb, Decl(privateNameInInExpression.ts, 41, 20))

        } else {
            fb; // good fb is Bar
>fb : Symbol(fb, Decl(privateNameInInExpression.ts, 41, 20))
        }

        if (#p1 in fs) {
>fs : Symbol(fs, Decl(privateNameInInExpression.ts, 41, 35))

            fs; // good fb is Foo (or FooSub?)
>fs : Symbol(fs, Decl(privateNameInInExpression.ts, 41, 35))

        } else {
            fs; // good fs is never
>fs : Symbol(fs, Decl(privateNameInInExpression.ts, 41, 35))
        }

        if (#p1 in b) {
>b : Symbol(b, Decl(privateNameInInExpression.ts, 41, 47))

            b; // good b is 'Bar & Foo'
>b : Symbol(b, Decl(privateNameInInExpression.ts, 41, 47))

        } else {
            b; // good b is Bar
>b : Symbol(b, Decl(privateNameInInExpression.ts, 41, 47))
        }

        if (#p1 in fsb) {
>fsb : Symbol(fsb, Decl(privateNameInInExpression.ts, 41, 55))

            fsb; // good fsb is FooSub
>fsb : Symbol(fsb, Decl(privateNameInInExpression.ts, 41, 55))

        } else {
            fsb; // good fsb is Bar
>fsb : Symbol(fsb, Decl(privateNameInInExpression.ts, 41, 55))
        }

        class Nested {
>Nested : Symbol(Nested, Decl(privateNameInInExpression.ts, 82, 9))

            m(v: any) {
>m : Symbol(Nested.m, Decl(privateNameInInExpression.ts, 84, 22))
>v : Symbol(v, Decl(privateNameInInExpression.ts, 85, 14))

                if (#p1 in v) {
>v : Symbol(v, Decl(privateNameInInExpression.ts, 85, 14))

                    v; // good v is Foo
>v : Symbol(v, Decl(privateNameInInExpression.ts, 85, 14))
                }
            }
        }
    }
}

class FooSub extends Foo { }
>FooSub : Symbol(FooSub, Decl(privateNameInInExpression.ts, 92, 1))
>Foo : Symbol(Foo, Decl(privateNameInInExpression.ts, 0, 0))

class Bar { notFoo = true }
>Bar : Symbol(Bar, Decl(privateNameInInExpression.ts, 94, 28))
>notFoo : Symbol(Bar.notFoo, Decl(privateNameInInExpression.ts, 95, 11))

function error(v: Foo) {
>error : Symbol(error, Decl(privateNameInInExpression.ts, 95, 27))
>v : Symbol(v, Decl(privateNameInInExpression.ts, 97, 15))
>Foo : Symbol(Foo, Decl(privateNameInInExpression.ts, 0, 0))

    return #p1 in v; // Bad - outside of class
>v : Symbol(v, Decl(privateNameInInExpression.ts, 97, 15))
}

export { }

