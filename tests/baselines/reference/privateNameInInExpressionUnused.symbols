=== tests/cases/conformance/classes/members/privateNames/privateNameInInExpressionUnused.ts ===
// TODO(aclaymore): verify we want this behavior

class Foo {
>Foo : Symbol(Foo, Decl(privateNameInInExpressionUnused.ts, 0, 0))

    private readonly unused: undefined; // expect unused error
>unused : Symbol(Foo.unused, Decl(privateNameInInExpressionUnused.ts, 2, 11))

    readonly #brand: undefined; // expect no error
>#brand : Symbol(Foo.#brand, Decl(privateNameInInExpressionUnused.ts, 3, 39))

    isFoo(v: any): v is Foo {
>isFoo : Symbol(Foo.isFoo, Decl(privateNameInInExpressionUnused.ts, 4, 31))
>v : Symbol(v, Decl(privateNameInInExpressionUnused.ts, 6, 10))
>v : Symbol(v, Decl(privateNameInInExpressionUnused.ts, 6, 10))
>Foo : Symbol(Foo, Decl(privateNameInInExpressionUnused.ts, 0, 0))

        // This should count as using/reading '#p1'
        return #brand in v;
>v : Symbol(v, Decl(privateNameInInExpressionUnused.ts, 6, 10))
    }
}

