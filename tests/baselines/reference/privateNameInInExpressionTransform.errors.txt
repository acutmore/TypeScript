tests/cases/conformance/classes/members/privateNames/privateNameInInExpressionTransform.ts(15,14): error TS2363: The right-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.
tests/cases/conformance/classes/members/privateNames/privateNameInInExpressionTransform.ts(15,21): error TS2361: The right-hand side of an 'in' expression must not be a primitive.
tests/cases/conformance/classes/members/privateNames/privateNameInInExpressionTransform.ts(17,14): error TS2363: The right-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.
tests/cases/conformance/classes/members/privateNames/privateNameInInExpressionTransform.ts(33,12): error TS18016: Private identifiers are not allowed outside class bodies.


==== tests/cases/conformance/classes/members/privateNames/privateNameInInExpressionTransform.ts (4 errors) ====
    // TODO(aclaymore) add cases for static fields
    
    class Foo {
        #p1 = 1;
        check(v: any) {
            #p1 in v; // expect `_p1.has(v)`
        }
        precedence(v: any) {
            // '==' has lower precedence than 'in'
            // '<'  has same precedence than 'in'
            // '<<' has higher precedence than 'in'
    
            v == #p1 in v == v; // Good precedence: ((v == (#p1 in v)) == v)
    
            v << #p1 in v << v; // Good precedence: (v << (#p1 in (v << v)))
                 ~~~~~~~~~~~~~
!!! error TS2363: The right-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.
                        ~~~~~~
!!! error TS2361: The right-hand side of an 'in' expression must not be a primitive.
    
            v << #p1 in v == v; // Good precedence: ((v << (#p1 in v)) == v)
                 ~~~~~~~~
!!! error TS2363: The right-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.
    
            v == #p1 in v < v; // Good precedence: (v == ((#p1 in v) < v))
    
            #p1 in v && #p1 in v; // Good precedence: ((#p1 in v) && (#p1 in v))
        }
    }
    
    class Bar {
        #p1 = 1;
        check(v: any) {
            #p1 in v; // expect `_p1_1.has(v)`
        }
    }
    
    function error(v: Foo) {
        return #p1 in v; // expect `in v`
               ~~~
!!! error TS18016: Private identifiers are not allowed outside class bodies.
    }
    
    export { }
    