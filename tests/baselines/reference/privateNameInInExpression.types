=== tests/cases/conformance/classes/members/privateNames/privateNameInInExpression.ts ===
// TODO(aclaymore) split up into separate cases

class Foo {
>Foo : Foo

    #field = 1;
>#field : number
>1 : 1

    static #staticField = 2;
>#staticField : number
>2 : 2

    #method() {}
>#method : () => void

    static #staticMethod() {}
>#staticMethod : () => void

    basics(v: any) {
>basics : (v: any) => void
>v : any

        const a = #field in v; // Good - a is boolean
>a : boolean
>#field in v : boolean
>v : any

        const b = #field in v.p1.p2; // Good - b is boolean
>b : boolean
>#field in v.p1.p2 : boolean
>v.p1.p2 : any
>v.p1 : any
>v : any
>p1 : any
>p2 : any

        const c = #field in (v as {}); // Good - c is boolean
>c : boolean
>#field in (v as {}) : boolean
>(v as {}) : {}
>v as {} : {}
>v : any

        const d = #field in (v as Foo); // Good d is boolean (not true)
>d : boolean
>#field in (v as Foo) : boolean
>(v as Foo) : Foo
>v as Foo : Foo
>v : any

        const e = #field in (v as never); // Good e is boolean
>e : boolean
>#field in (v as never) : boolean
>(v as never) : never
>v as never : never
>v : any

        const f = #field in (v as unknown); // Bad - RHS of in must be object type or any
>f : boolean
>#field in (v as unknown) : boolean
>(v as unknown) : unknown
>v as unknown : unknown
>v : any

        const g = #typo in v; // Bad - Invalid privateID
>g : any
>#typo in v : any
>v : any

        const h = (#field) in v; // Bad - private id is not an expression on its own
>h : boolean
>(#field) in v : boolean
>(#field) : any
>#field : any
>v : any

        for (#field in v) { /* no-op */ } // Bad - 'in' not allowed
>#field : any
>v : any

        for (let x in #field in v) { /* no-op */ } // Bad - rhs of in should be a object/any
>x : string
>#field in v : boolean
>v : any

        for (let x in #field in v as any) { /* no-op */ } // Good - weird but valid
>x : string
>#field in v as any : any
>#field in v : boolean
>v : any

    }
    whitespace(v: any) {
>whitespace : (v: any) => void
>v : any

        const a = v && /*0*/#field/*1*/
>a : any
>v && /*0*/#field/*1*/            /*2*/in/*3*/                /*4*/v : any
>v : any
>#field/*1*/            /*2*/in/*3*/                /*4*/v : boolean

            /*2*/in/*3*/
                /*4*/v/*5*/
>v : any
    }
    flow(u: unknown, n: never, fb: Foo | Bar, fs: FooSub, b: Bar, fsb: FooSub | Bar) {
>flow : (u: unknown, n: never, fb: Foo | Bar, fs: FooSub, b: Bar, fsb: FooSub | Bar) => void
>u : unknown
>n : never
>fb : Foo | Bar
>fs : FooSub
>b : Bar
>fsb : Bar | FooSub

        if (typeof u === 'object') {
>typeof u === 'object' : boolean
>typeof u : "string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "object" | "function"
>u : unknown
>'object' : "object"

            if (#field in n) {
>#field in n : boolean
>n : never

                n; // good n is never
>n : never
            }

            if (#field in u) {
>#field in u : boolean
>u : object | null

                u; // good u is Foo
>u : Foo

            } else {
                u; // good u is object | null
>u : object | null
            }

            if (u !== null) {
>u !== null : boolean
>u : object | null
>null : null

                if (#field in u) {
>#field in u : boolean
>u : object

                    u; // good u is Foo
>u : Foo

                } else {
                    u; // good u is object
>u : object
                }

                if (#method in u) {
>#method in u : boolean
>u : object

                    u; // good u is Foo
>u : Foo
                }

                if (#staticField in u) {
>#staticField in u : boolean
>u : object

                    u; // good u is typeof Foo
>u : typeof Foo
                }

                if (#staticMethod in u) {
>#staticMethod in u : boolean
>u : object

                    u; // good u is typeof Foo
>u : typeof Foo
                }
            }
        }

        if (#field in fb) {
>#field in fb : boolean
>fb : Foo | Bar

            fb; // good fb is Foo
>fb : Foo

        } else {
            fb; // good fb is Bar
>fb : Bar
        }

        if (#field in fs) {
>#field in fs : boolean
>fs : FooSub

            fs; // good fs is FooSub
>fs : FooSub

        } else {
            fs; // good fs is never
>fs : never
        }

        if (#field in b) {
>#field in b : boolean
>b : Bar

            b; // good b is 'Bar & Foo'
>b : Bar & Foo

        } else {
            b; // good b is Bar
>b : Bar
        }

        if (#field in fsb) {
>#field in fsb : boolean
>fsb : Bar | FooSub

            fsb; // good fsb is FooSub
>fsb : FooSub

        } else {
            fsb; // good fsb is Bar
>fsb : Bar
        }

        class Nested {
>Nested : Nested

            m(v: any) {
>m : (v: any) => void
>v : any

                if (#field in v) {
>#field in v : boolean
>v : any

                    v; // good v is Foo
>v : Foo
                }
            }
        }
    }
}

class FooSub extends Foo { subTypeOfFoo = true }
>FooSub : FooSub
>Foo : Foo
>subTypeOfFoo : boolean
>true : true

class Bar { notFoo = true }
>Bar : Bar
>notFoo : boolean
>true : true

function error(v: Foo) {
>error : (v: Foo) => any
>v : Foo

    return #field in v; // Bad - outside of class
>#field in v : any
>v : Foo
}

export { }

