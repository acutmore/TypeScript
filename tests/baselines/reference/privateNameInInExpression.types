=== tests/cases/conformance/classes/members/privateNames/privateNameInInExpression.ts ===
// TODO(aclaymore) split up into seperate cases

class Foo {
>Foo : Foo

    #p1 = 1;
>#p1 : number
>1 : 1

    basics(v: any) {
>basics : (v: any) => void
>v : any

        const a = #p1 in v; // Good - a is boolean
>a : boolean
>v : any

        const b = #p1 in v.p1.p2; // Good - b is boolean
>b : boolean
>v.p1.p2 : any
>v.p1 : any
>v : any
>p1 : any
>p2 : any

        const c = #p1 in (v as {}); // Good - c is boolean
>c : boolean
>(v as {}) : {}
>v as {} : {}
>v : any

        const d = #p1 in (v as Foo); // Good d is boolean (not true)
>d : boolean
>(v as Foo) : Foo
>v as Foo : Foo
>v : any

        const e = #p1 in (v as unknown); // Bad - RHS of in must be object type or any
>e : boolean
>(v as unknown) : unknown
>v as unknown : unknown
>v : any

        const f = #p2 in v; // Bad - Invalid privateID
>f : any
>v : any

        const g = (#p1) in v; // Bad - private id is not an expression on it's own
>g : boolean
>(#p1) in v : boolean
>(#p1) : any
>v : any

        for (#p1 in v) { /* no-op */ } // Bad - 'in' not allowed
>#p1 : any
>v : any

        for (let x in #p1 in v) { /* no-op */ } // Bad - rhs of in should be a object/any
>x : string
>v : any

        for (let x in #p1 in v as any) { /* no-op */ } // Good - weird but valid
>x : string
>#p1 in v as any : any
>v : any

    }
    precedence(v: any) {
>precedence : (v: any) => void
>v : any

        // '==' has lower precedence than 'in'
        // '<'  has same prededence than 'in'
        // '<<' has higher prededence than 'in'

        v == #p1 in v == v; // Good precidence: ((v == (#p1 in v)) == v)
>v == #p1 in v == v : boolean
>v == #p1 in v : boolean
>v : any
>v : any
>v : any

        v << #p1 in v << v; // Good precidence: (v << (#p1 in (v << v)))
>v << #p1 in v << v : number
>v : any
>v << v : number
>v : any
>v : any

        v << #p1 in v == v; // Good precidence: ((v << (#p1 in v)) == v)
>v << #p1 in v == v : boolean
>v << #p1 in v : number
>v : any
>v : any
>v : any

        v == #p1 in v < v; // Good precidence: (v == ((#p1 in v) < v))
>v == #p1 in v < v : boolean
>v : any
>#p1 in v < v : boolean
>v : any
>v : any

        #p1 in v && #p1 in v; // Good precidence: ((#p1 in v) && (#p1 in v))
>#p1 in v && #p1 in v : boolean
>v : any
>v : any
    }
    flow(v: unknown) {
>flow : (v: unknown) => void
>v : unknown

        if (typeof v === 'object' && v !== null) {
>typeof v === 'object' && v !== null : boolean
>typeof v === 'object' : boolean
>typeof v : "string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "object" | "function"
>v : unknown
>'object' : "object"
>v !== null : boolean
>v : object | null
>null : null

            if (#p1 in v) {
>v : any

                const y1 = v; // good y1 is typeof Foo
>y1 : Foo
>v : Foo

            } else {
                const y2 = v; // y2 is not typeof Foo
>y2 : object
>v : object
            }
        }

        class Nested {
>Nested : Nested

            m(v: any) {
>m : (v: any) => void
>v : any

                if (#p1 in v) {
>v : any

                   const y1 = v; // Good y1 if typeof Foo
>y1 : Foo
>v : Foo
                }
            }
        }
    }
}

function error(v: Foo) {
>error : (v: Foo) => any
>v : Foo

    return #p1 in v; // Bad - outside of class
>v : any
}

